# Guides: Configuring Pod Containers

Configuring application containers comprises understanding the following
concepts:

### Configuring Commands and Arguments on Containers

Passing command and arguments occurs the same way as with building a Docker
image and running a container.

Specify CMD with the shell format:

```dockerfile
CMD sleep 51
```

Specify the command and arguments in JSON array format:

```dockerfile
CMD [ "sleep", "5" ]
```

NOTE: It would be an error to specify the command and arguments in a single
string like `"sleep 10"` because the first argument of the array is expected
to be a valid command that can be executed in the container when it is running,
so the terminal would try to run "sleep 10" as a single command and throw an
error. This is important to understand and remember!

Specify the command as the entrypoint:

```dockerfile
ENTRYPOINT [ "sleep" ]
```

NOTE: When the container is run, any arguments passed are treated as arguments
to the entrypoint. For example, if we built an image named "sleep-process"
with "sleep" as the entrypoint; we could tell it to sleep for 5 seconds by
providing an argument when running the image like so:

```shell
docker run sleep-process 5
```

To make our image more reusable, we can set a default argument by setting a
value for the `CMD` field, in case the user decides to run our "sleep-process"
without any arguments, here's how:

```dockerfile
ENTRYPOINT [ "sleep" ]
CMD [ "5" ]
```

NOTE: Now we can run our image with no arguments or override the default with
10 seconds or whatever we decide, like so:

```shell
docker run sleep-process
docker run sleep-process 10
```

The first would run for 5 seconds (minus any start and shutdown time), and the
second will run for 10 seconds, overriding the default 5 seconds set in the
image.

It is a common practice to set the entrypoint to a command and then set the CMD to the help flag so that when an image is run without arguments, then the user gets the help/guide like so:

```dockerfile
ENTRYPOINT [ "sleep" ]
CMD [ "--help" ]
```

When specifying the command in a POD spec containers[].command, it unintuitively
corresponds to the `ENTRYPOINT` of the Dockerfile, and the "args", unintuitively
correspond to the `CMD` in the Dockerfile. Please remember that.

### Configuring Environment Variables

Use the `env:` field in the spec of a Pod.

```yaml
env:
  - name: MY_VAR
    value: abc
  - name: FROM_CONFIG_MAP
    valumeFrom:
      configMapKeyRef:
  - name: VAR3
    valueFrom:
      secretKeyRef:
```

### ConfigMap

There are 2 steps to using config-maps with Pods.

1. Make the config map
2. Reference the config map

Name configmaps appropriately so you remember where they are used and what they
may contain.

You can make config-maps using:

**imperative way**:

```shell
k create configmap <config-name> --from-literal=<key>=<value>
```

NOTE: You can specify `--from-literal` for additional variables.
When this gets to be too many variables, you can specify the `--from-file`
option with a file containing your variables.

**declarative way**:

**Provide a file**:

```yaml
# app-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config

data:
  VAR1: val1
  VAR2: val2
```

View configmaps:
`k get configmaps`

`k describe configmaps <config-map-name>`


**Reference a Config-Map in a Pod**:

```yaml
spec:
  containers:
    - name:
      envFrom:
        - configMapRef:
            name: app-config
      env:
        - name: VAR1
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: VAR1
      volumeMounts:
        # name must match the volume name below
        - name: app-config-volume
          mountPath: /etc/app-config-volume
          readOnly: true

  volumes:
    - name: app-config-volume
      configMap:
        name: app-config
```

### Configuring Secrets

1. Create a secret
2. Use it in a file

**imperative way**

`kubectl create secret generic --from-literal=key=value`

NOTE: You can supply the `--from-literal` multiple times.

You can also use a file: `k create secret generic -f ...`

**declarative way**

You specify a file.

`k create -f ...`

However, the data for the values needs to be 64bit encoded.

`echo -n 'password' | base64` and paste that in the file for the value.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-config

data:
  VAR1: val1
  VAR2: val2
```

View secrets:

`k get secrets`
`k describe secrets`
`k get secrets app-config -o yaml`


decode a secret: `echo "adfafdas= | base64 --decode`

To add a Secret to a pod use the `envFrom.secretRef.name`:


```yaml
spec:
  containers:
    - name: webapp
      envFrom: #Load all secrets from a config-map
        secretRef:
          name: app-config
      env:
        - name: DB_Password
          valueFrom:
            secretKeyRef:
              name: app-config
              key: DB_Password
      volumeMounts:
        # name must match the volume name below
        - name: app-config-vol
          mountPath: /opt/secret-volume
          readOnly: true
  volumes:
    - name: app-config-vol
      secret:
        secretName: app-config
```
When you use a volume each secret is stored as a file in the volume
`/opt/app-config/DB_Password`

Secrets are not encrypted, but just encoded. DO NOT check them into your
repository.

* Secrets are NOT encrypted in ETCD.
* Anyone able to create pods/deployment in a namespace can access those secrets.
* Configure least-privilege access to secrets - RBAC
* Consider third party secret store providers like AWS Secrets Manager. Or
  better you can use an S3 bucket for secrets, just encrypt them with you own
  GPG key or something.

```shell
k create secret generic db-secret \
  --from-literal=DB_Host=sql01 \
  --from-literal=DB_User=root \
  --from-literal=DB_Password=password123 \
  --dry-run=client -o yaml
```