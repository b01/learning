# Volumes

At its core, a volume is either a directory or a file.

## Volume Types

No need to memorize every type. Just some important facts about certain types
when attempting to utilize them.

### configMap

A ConfigMap provides a way to inject configuration data into pods.

When referencing a ConfigMap, you provide the name of the ConfigMap in the
volume.

You can customize the path to use for a specific entry in the ConfigMap.

You must create a ConfigMap before you can use it.

A ConfigMap is always mounted as readOnly.

A container using a ConfigMap as a subPath volume mount will not receive
updates when the ConfigMap changes.

Text data is exposed as files using the UTF-8 character encoding. For other
character encodings, use binaryData.

For example:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: log-config
data:
  log_level: |
    {
      "level": "warn"
    }
---
apiVersion: v1
kind: Pod
metadata:
  name: configmap-podspec-example
spec:
  containers:
    - name: container-at-index-0
      image: busybox
      command: ['sleep', '300']
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config # this can be any path you like.
  volumes:
    - name: config-map-vol
      configMap:
        name: log-config
        items:
          - key: log_level
            path: log_level.conf
```
### secret
A `secret` volume is used to pass sensitive information, such as passwords, to
Pods.

`secret` volumes are backed by tmpfs (a RAM-backed filesystem) so they are
never written to non-volatile storage.

### local

* Local volumes can only be used as a statically created PersistentVolume.
* Are subject to the availability of the underlying node. If a node becomes
  unhealthy, then the local volume becomes inaccessible to the pod.
* You must set a PersistentVolume nodeAffinity when using local volumes. The
  Kubernetes scheduler uses the PersistentVolume nodeAffinity to schedule
  these Pods to the correct node.
* `volumeMode` can be set to "Block" (instead of the default value
  "Filesystem")
* It is recommended to create a StorageClass with `volumeBindingMode` set to
  **WaitForFirstConsumer**. Delaying volume binding ensures that the
  PersistentVolumeClaim binding decision will also be evaluated with any other
  node constraints the Pod may have, such as node resource requirements, node
  selectors, Pod affinity, and Pod anti-affinity.
* The local PersistentVolume requires manual cleanup and deletion by the user
  if the external static provisioner is not used to manage the volume lifecycle.

## Review before an Exam

Here are a few that  you should review before an exam.

* [emptyDir]: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
* [configMap]: https://kubernetes.io/docs/concepts/storage/volumes/#configmap
* [AWS EBS]: https://github.com/kubernetes-sigs/aws-ebs-csi-driver
* [nfs]: https://kubernetes.io/docs/concepts/storage/volumes/#nfs

### Ephemeral volumes

This type of volumes:
* follows the Pod's lifetime, meaning they are made when
  the pod starts and deleted along with the Pod.
* are specified inline in the Pod spec

emptyDir, configMap, downwardAPI, secret are of this type, and provided as
local ephemeral storage. They are managed by kubelet on each node.
