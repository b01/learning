# Storage Class

Is a way for cluster administrators to offer storage in tiers to
be made available to pods. Different classes might map to quality-of-service
levels, backup policies, or arbitrary policies for given use cases.

* Dynamic provisioning can be enabled on a cluster by marking a default
  `StorageClass` and enabling the `DefaultStorageClass` admission controller
  on the API server.

A storage class spec requires these top-level fields:
* `apiVersion` - set to `storage.k8s.io/v1`
* `kind` - set to `StorageClass` to specify its resource type.
* `metadata` - a dictionary which must contain a "name", and should have a
  "labels" fields. The "labels" can be a dictionary with any keys you
  desire/need.

  NOTE: The name of a StorageClass object is significant, and is used in
  [Persistent Volumes] and [Persistent Volume Claims] to request a particular
  class.
* Contains the fields `provisioner`, `parameters`, and `reclaimPolicy`, and used
  when a PersistentVolume belonging to the class needs to be dynamically
  provisioned to satisfy a PersistentVolumeClaim (PVC).
* To set a default StorageClass use the `metadata` `annotations` key to set
  `storageclass.kubernetes.io/is-default-class: "true"`
* `volumeBindingMode` - controls when volume binding and dynamic provisioning
  should occur.

```yaml
# sc-efs.yml
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: efs-sc
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: efs.csi.aws.com
parameters:
  provisioningMode: efs-ap
  fileSystemId: fs-92107410
  directoryPerms: "700"
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
```

Local storage example:

```yaml
# sc-local.yml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner # indicates that this StorageClass does not support automatic provisioning
volumeBindingMode: WaitForFirstConsumer
```

NOTE: Local volumes do not support dynamic provisioning in Kubernetes 1.33;
however a StorageClass should still be created to delay volume binding
until a Pod is actually scheduled to the appropriate node. This is achieved
by setting `volumeBindingMode` to `WaitForFirstConsumer`.

WARNING: Do not use `nodeName` in the Pod spec when the storage class has 
`volumeBindingMode` set to `WaitForFirstConsumer`. This will cause the PVC
to get stuck in "Pending" mode. If you want to ensure a Pod is deployed to a
specific node, then use [nodeSelector], which must match at least one label
that is specific to that node. Using the hostname for example:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: worker-01-pod
  labels:
    app: nginx
    kind: server
    mode: backend
    type: dynamic
    format: html
spec:
  containers:
    - name: "worker-01-pods"
      image: nginx
  nodeSelector:
    kubernetes.io/hostname: "worker-01"
```

NOTE: You can list a node's labels using `kubectl get nodes --show-labels`.
This can fail if you do not have permissions to read this data.

## Volume Binding Mode

The `volumeBindingMode` field controls when volume binding and dynamic
provisioning should occur.

* If you choose to use  **WaitForFirstConsumer** option, do not use `nodeName`
  in the Pod spec to specify node affinity. If `nodeName` is used in this case,
  then the scheduler will be bypassed and PVC will remain in pending state.
  Instead, you can use `kubernetes.io/hostname`:
  ```yaml
  spec:
    nodeSelector:
      kubernetes.io/hostname: worker-01
  ```
* When the **WaitForFirstConsumer** volume binding mode is specified in the
  StorageClass object; it is no longer necessary to restrict provisioning to
  specific topologies in most situations. If still required,
  `allowedTopologies` can be specified:
  ```yaml
  allowedTopologies:
    - matchLabelExpressions:
      - key: topology.kubernetes.io/zone
        values:
        - us-central-1a
        - us-central-1b
  ```

---

[Persistent Volumes]: /kubernetes/10.2-persistent-volumes
[Persistent Volume Claims]: /kubernetes/10.2-persistent-volumes
[nodeSelector]: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
