# Secrets

An object that contains a small amount of sensitive data such as a password.

Using a Secret means that you don't need to include confidential data in your
application code.

Can be created independently of the Pods that use them.

Kubernetes Secrets are, by default, stored unencrypted in the API server's
underlying data store (etcd). Anyone with API access can retrieve or modify a
Secret.

In order to safely use Secrets, take at least the following steps:
1. Enable Encryption at Rest for Secrets.
2. Enable or configure RBAC rules with least-privilege access to Secrets.
3. Restrict Secret access to specific containers.

## Types of Secret

* `type` - is used to facilitate programmatic handling of the Secret data.
  Define your own `type` by assigning a non-empty string as the value. An empty
  string is treated as an `Opaque` type. When using one of the built-in types,
  you must meet all the requirements defined for that type. When defining a
  type of Secret that's for public use, the convention is to have your domain
  name before the name, separated by a /. For example,
  `<domain-name>/<secrect-name>`.

### ServiceAccount token Secrets

The recommended approach is to obtain a short-lived, automatically rotating
ServiceAccount token by calling the TokenRequest API with :
* `kubectl create token` command.
* Request a mounted token in a [projected volume] in your Pod manifest. It is
  automatically invalidated when that Pod is deleted.
  ```yaml
  ...
    - name: sample-container
      projected:
        sources:
          - serviceAccountToken:
              path: /token # must match the path the app expects
   ```

A `kubernetes.io/service-account-token` type of Secret is used as a
ServiceAccount token, a legacy mechanism that provides long-lived credentials
to Pods.

You need to ensure that the `kubernetes.io/service-account.name` annotation is
set to an existing ServiceAccount name.
```yaml
#
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    kubernetes.io/enforce-mountable-secrets: "true"
  name: sa-name
  namespace: personal
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: sa-name
  name: secret-sa-sample
  namespace: personal
type: kubernetes.io/service-account-token
data:
  extra: 000000==

```

### Docker config Secrets

Used to store credentials for accessing a container image registry.

Use one of the following type values
* `kubernetes.io/dockercfg` - legacy format, stores a serialized `~/.dockercfg`
  for configuring Docker command line. The `data` field contains a
  `.dockercfg` key whose value is the content of a base64 encoded ~/.dockercfg
  file.
  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: secret-dockercfg
  type: kubernetes.io/dockercfg
  data:
    .dockercfg: |
      000000000000000000000000000000000000000000000000000000000000000000000000000=
  ```
* `kubernetes.io/dockerconfigjson` - store a serialized JSON that follows the
  same format rules as the ~/.docker/config.json file. The Secret `data` field
  must contain a `.dockerconfigjson` key and the value of a base64 encoded
  `~/.docker/config.json` file.

Note: Skip the base64 encoding by using `stringData` field instead.

Use `kubectl` to make a Docker Secret for when you don't have a Docker
configuration file.
```shell
kubectl create secret docker-registry example-docker-secret \
  --docker-email=docker@example.com \
  --docker-username=dockerUser \
  --docker-password=pass1234 \
  --docker-server=docker-registry.example.com:500
```

## Working with Secrets

The name of a Secret object must be a valid DNS subdomain name.
* The keys of `data` and `stringData` must consist of alphanumeric characters,
  `-`, `_` or `.`. All key-value pairs in the `stringData` field are internally
  merged into the `data` field. If a key appears in both the data and the
  `stringData` field, the value specified in the `stringData` field takes
  precedence.
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: personal
  namespace: personal-space
type: Opaque
data:
  db_pass: 00000000 # base64 encoded
stringData:
  docker_pass: "easy123" # plain text
```

You can edit an existing Secret unless it is immutable.
You can create an immutable Secret by setting the `immutable` field to true.
```yaml
apiVersion: v1
kind: Secret
metadata: {}
data: {}
immutable: true
```
Depending on how you created the Secret, as well as how the Secret is used in
your Pods, updates to existing Secret objects are propagated automatically to
Pods that use the data.

Secrets can be mounted as data volumes or exposed as environment variables.

If the Secret cannot be fetched the `kubelet` periodically retries running that
Pod and reports an Event.

If it exists, but is missing a named key, the Pod still fails.

You can mark the Secret as optional, if it doesn't exist, then Kubernetes
ignores it.
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      optional: true
```

When a volume contains data from a Secret (except as a subPath volume), and
that Secret is updated, Kubernetes tracks this and updates the data in the
volume, using an eventually-consistent approach.

You cannot use ConfigMaps or Secrets with static Pods.

## Container image pull Secrets

Make a new namespace.
```shell
kubectl create namespace personal-space
```
Make an `imagePullSecret`
```shell
kubectl create secret docker-registry example-docker --docker-server=docker-registry.example.com:500 \
        --docker-username=dockerUser --docker-password=pass1234 \
        --docker-email=docker@example.com \
        -n personal-space
```

Next, modify the default service account for the namespace to use this Secret as an `imagePullSecret`.
```shell
kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "kohirens"}]}' -n personal-space
```

## Information security for Secrets

A Secret is only sent to a node if a Pod on that node requires it.

The `kubelet` stores a copy of the data into a tmpfs so that the confidential
data is not written to durable storage.

Once the Pod that depends on the Secret is deleted, the `kubelet` deletes its
local copy.

Containers you define only have access to the default ServiceAccount and its
related Secret. Otherwise, you must explicitly define environment variables
or map a volume to provide access to any others.

One Pod does not have access to the Secrets of another Pod.

To enhance the security, use separate namespaces to isolate access to mounted
secrets.

Any containers that run with `privileged: true` on a node can access all Secrets
used on that node. This ruins secrets for most use cases. Its best to use an
external Secrets manager.

---

[projected volume]: https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume