# Connecting Applications with Services

This information is based on the official Kubernetes
[Connecting Applications with Services] document.

**Kubernetes model for connecting containers**

When you have a working cluster and have deployed a replicated application, you
can then expose it on a network.

Kubernetes assumes that pods can communicate with other pods, regardless of
which host they land on.

Every Pod has its own cluster-private IP address automatically. Meaning:

* No need to explicitly create links or map container ports to host ports.
* Containers within a Pod can all reach each other's ports on localhost.
* All Pods in a cluster can see each other without NAT.

Making a certificate we can use for TLS with the Service.
```shell
openssl genrsa -out "nginx.key" 2048
openssl req -x509 -new -nodes \
    -key "nginx.key" \
    -subj "/CN=my-nginx" \
    -days 365 -out "nginx.crt"

kubectl create secret tls nginxsecret --key nginx.key --cert nginx.crt
```

Make an Nginx config and save it to the cluster as a ConfigMap.
```shell
cat <<TXT | kubectl apply -f -
apiVersion: v1
king: ConfigMap
metadata:
  name: nginxconfigmap
data:
  default.conf: |
    server {
        listen 80 default_server;
        listen [::]:80 default_server ipv6only=on;

        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        root /usr/share/nginx/html;
        index index.html;

        server_name localhost;
        ssl_certificate /etc/nginx/ssl/tls.crt;
        ssl_certificate_key /etc/nginx/ssl/tls.key;

        charset utf-8;

        location / {
                index  index.html;
        }
    }
TXT
```

Verify `nginxconfigmap` ConfigMap was saved.
```shell
kubectl describe configmap nginxconfigmap
```

Next, delete the `my-nginx` service and deployment.
```shell
kubectl delete svc,deploy my-nginx
```

Then remake the service to use HTTPS
```shell
cat <<TXT | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    run: my-nginx
spec:
  type: NodePort
  ports:
  - port: 8080
    targetPort: 80
    protocol: TCP
    name: http
  - port: 443
    protocol: TCP
    name: https
  selector:
    run: my-nginx
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      volumes:
      - name: secret-volume
        secret:
          secretName: nginxsecret
      - name: configmap-volume
        configMap:
          name: nginxconfigmap
      containers:
      - name: nginxhttps
        image: nginx:1.29.0
        ports:
        - containerPort: 443
        - containerPort: 80
        volumeMounts:
        - mountPath: /etc/nginx/ssl
          name: secret-volume
        - mountPath: /etc/nginx/conf.d
          name: configmap-volume
TXT
```

We'll also make another Deployment where we can test Pod-to-Pod communication.
```shell
cat <<TXT | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: curl-deployment
spec:
  selector:
    matchLabels:
      app: curlpod
  replicas: 1
  template:
    metadata:
      labels:
        app: curlpod
    spec:
      volumes:
      - name: secret-volume
        secret:
          secretName: nginxsecret
      containers:
      - name: curlpod
        command:
        - sh
        - -c
        - while true; do sleep 1; done
        image: alpine/curl
        volumeMounts:
        - mountPath: /etc/nginx/ssl
          name: secret-volume
TXT
```

Test Pod-to-Pod communication works!
```shell
kubectl get po -l app=curlpod
kubectl exec <enter-curl-deployment-pod-name> -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
```

---

[Connecting Applications with Services]: https://kubernetes.io/docs/tutorials/services/connect-applications-service/
